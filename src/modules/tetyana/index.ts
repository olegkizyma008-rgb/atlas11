import { TetyanaAPI } from './contract';
import { ForgeAPI } from '../forge/contract';
import { VoiceAPI } from '../../kontur/voice/contract';
import { BrainAPI } from '../brain/contract';
import { TetyanaExecutor } from './executor';
import { Core } from '../../kontur/core/dispatcher';
import { KPP_Packet, PacketIntent } from '../../kontur/protocol/nexus';
import { Plan } from '../atlas/contract';

export class TetyanaCapsule implements TetyanaAPI {
    private forge: ForgeAPI;
    private voice: VoiceAPI;
    private brain: BrainAPI;
    public executor: TetyanaExecutor; // Public for deep integration wiring

    constructor(forge: ForgeAPI, voice: VoiceAPI, brain: BrainAPI, core?: Core) {
        this.forge = forge;
        this.voice = voice;
        this.brain = brain;

        if (core) {
            this.executor = new TetyanaExecutor(core);
        } else {
            // Fallback for tests or legacy init without core
            // We generally expect Core to be injected or attached later
            console.warn("TETYANA: Core not provided in constructor. Executor detached.");
            this.executor = new TetyanaExecutor({ ingest: () => { } } as any);
        }
    }

    /**
     * Handle incoming KPP Packet (The Nervous Handshake)
     */
    public processPacket(packet: KPP_Packet) {
        // 1. If it's a Plan -> Start Execution
        if (packet.instruction.intent === PacketIntent.AI_PLAN && packet.payload.steps) {
            console.log('[TETYANA] ðŸ“œ Received Plan via Packet');
            const plan: Plan = {
                id: packet.nexus.uid,
                goal: packet.payload.goal || 'Execution',
                steps: packet.payload.steps,
                user_response_ua: packet.payload.user_response_ua,
                status: 'pending'
            };
            this.executor.execute(plan);
            return;
        }

        // 2. If it's a Response/Event -> Feed to Executor (for step confirmation)
        if (packet.instruction.intent === PacketIntent.RESPONSE || packet.instruction.intent === PacketIntent.ERROR) {
            this.executor.handleIncomingPacket(packet);
        }
    }

    // --- Legacy API Methods (kept for contract compliance, but wrapping executor logic where possible) ---

    async execute(args: { tool: string; args: Record<string, any> }) {
        console.log(`TETYANA: Direct Execute Call ${args.tool}`);
        // This bypasses the executor loop - used for single-shot tools?
        // Ideally we wrap this in a mini-plan 
        await this.voice.speak({ text: `Executing ${args.tool}`, voice: 'tetyana' });
        const output = await this.forge.execute({ tool_name: args.tool, args: args.args });
        return { success: true, output };
    }

    async forge_tool(args: { name: string; spec: string }) {
        console.log(`TETYANA: Forging tool ${args.name}...`);

        const response = await this.brain.think({
            system_prompt: `You are TETYANA, the Builder. Generate a TypeScript tool named "${args.name}". Return ONLY the code.`,
            user_prompt: `Spec: ${args.spec}`
        });

        const result = await this.forge.synthesize({
            name: args.name,
            description: "Auto-generated by Tetyana via Brain",
            code: response.text || '// Error generating code'
        });
        return result.path || '';
    }
}

/**
 * KONTUR CLI - Environment Manager
 * Reads and writes .env file for provider configuration
 */

import * as fs from 'fs';
import * as path from 'path';

const ENV_PATH = path.join(process.cwd(), '.env');

export interface EnvConfig {
    [key: string]: string;
}

/**
 * Read .env file and parse into object
 */
export function readEnv(): EnvConfig {
    if (!fs.existsSync(ENV_PATH)) {
        return {};
    }

    const content = fs.readFileSync(ENV_PATH, 'utf-8');
    const config: EnvConfig = {};

    content.split('\n').forEach(line => {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith('#')) return;

        const eqIndex = trimmed.indexOf('=');
        if (eqIndex > 0) {
            const key = trimmed.substring(0, eqIndex).trim();
            const value = trimmed.substring(eqIndex + 1).trim();
            config[key] = value;
        }
    });

    return config;
}

/**
 * Write config to .env file, preserving comments
 */
export function writeEnv(config: EnvConfig): void {
    let content = '';

    // Read existing file to preserve comments and order
    if (fs.existsSync(ENV_PATH)) {
        const existing = fs.readFileSync(ENV_PATH, 'utf-8');
        const usedKeys = new Set<string>();

        content = existing.split('\n').map(line => {
            const trimmed = line.trim();
            if (!trimmed || trimmed.startsWith('#')) return line;

            const eqIndex = trimmed.indexOf('=');
            if (eqIndex > 0) {
                const key = trimmed.substring(0, eqIndex).trim();
                usedKeys.add(key);
                if (key in config) {
                    return `${key}=${config[key]}`;
                }
            }
            return line;
        }).join('\n');

        // Add new keys that weren't in the file
        const newKeys = Object.keys(config).filter(k => !usedKeys.has(k));
        if (newKeys.length > 0) {
            content += '\n\n# Added by CLI\n';
            newKeys.forEach(key => {
                content += `${key}=${config[key]}\n`;
            });
        }
    } else {
        // Create new file
        content = '# KONTUR Configuration\n# Generated by CLI\n\n';
        Object.entries(config).forEach(([key, value]) => {
            content += `${key}=${value}\n`;
        });
    }

    fs.writeFileSync(ENV_PATH, content);
}

/**
 * Get a specific env value
 */
export function getEnv(key: string): string | undefined {
    const config = readEnv();
    return config[key];
}

/**
 * Set a specific env value
 */
export function setEnv(key: string, value: string): void {
    const config = readEnv();
    config[key] = value;
    writeEnv(config);
}

/**
 * Service configuration helpers
 */
export type ServiceType = 'brain' | 'tts' | 'stt' | 'vision' | 'reasoning';

export interface ServiceConfig {
    provider: string;
    model: string;
    fallback?: string;
    apiKey?: string;
}

export function getServiceConfig(service: ServiceType): ServiceConfig {
    const prefix = service.toUpperCase();
    const config = readEnv();

    return {
        provider: config[`${prefix}_PROVIDER`] || 'gemini',
        model: config[`${prefix}_MODEL`] || getDefaultModel(service),
        fallback: config[`${prefix}_FALLBACK_PROVIDER`],
        apiKey: config[`${prefix}_API_KEY`] || config['GEMINI_API_KEY']
    };
}

export function setServiceConfig(service: ServiceType, cfg: Partial<ServiceConfig>): void {
    const prefix = service.toUpperCase();
    const config = readEnv();

    if (cfg.provider) config[`${prefix}_PROVIDER`] = cfg.provider;
    if (cfg.model) config[`${prefix}_MODEL`] = cfg.model;
    if (cfg.fallback) config[`${prefix}_FALLBACK_PROVIDER`] = cfg.fallback;
    if (cfg.apiKey) config[`${prefix}_API_KEY`] = cfg.apiKey;

    writeEnv(config);
}

function getDefaultModel(service: ServiceType): string {
    const defaults: Record<ServiceType, string> = {
        brain: 'gemini-2.5-flash',
        tts: 'gemini-2.5-flash-preview-tts',
        stt: 'gemini-2.5-flash',
        vision: 'gemini-2.5-flash-native-audio-preview-09-2025',
        reasoning: 'gemini-3-pro-preview'
    };
    return defaults[service];
}
